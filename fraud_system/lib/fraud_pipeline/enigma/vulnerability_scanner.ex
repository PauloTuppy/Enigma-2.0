defmodule FraudPipeline.Enigma.VulnerabilityScanner do
  @moduledoc "Escaneia vulnerabilidades em bets fraudulentas"

  require Logger

  @doc "Escaneia alvo por vulnerabilidades comuns"
  def scan_target(target_url) do
    Logger.info("ðŸ” Iniciando scan: #{target_url}")

    [
      scan_env_exposure(target_url),
      scan_sql_injection(target_url),
      scan_xss_vulnerabilities(target_url),
      scan_git_exposure(target_url),
      scan_api_keys(target_url),
      scan_weak_auth(target_url)
    ]
    |> Enum.filter(&elem(&1, 1))
  end

  # Pattern 1: .env exposure
  defp scan_env_exposure(target) do
    endpoints = ["/.env", "/.env.local", "/.env.example", "/config/.env"]

    found =
      Enum.find(endpoints, fn endpoint ->
        case HTTPoison.get("#{target}#{endpoint}") do
          {:ok, %HTTPoison.Response{status_code: 200}} -> true
          _ -> false
        end
      end)

    if found do
      Logger.warning("ðŸš¨ .env EXPOSED: #{target}#{found}")
      {:env_exposure, %{endpoint: found, severity: 5, url: "#{target}#{found}"}}
    else
      {:env_exposure, nil}
    end
  end

  # Pattern 2: SQL Injection
  defp scan_sql_injection(target) do
    payloads = [
      "' OR '1'='1",
      "1' UNION SELECT * FROM users--",
      "admin'--",
      "1; DROP TABLE transactions--"
    ]

    found =
      Enum.find(payloads, fn payload ->
        case HTTPoison.get("#{target}/api/transactions?user_id=#{URI.encode(payload)}") do
          {:ok, %HTTPoison.Response{status_code: 500}} -> true # 500 often indicates SQL error
          _ -> false
        end
      end)

    if found do
      Logger.warning("ðŸš¨ SQL INJECTION VULNERABLE: #{target}")
      {:sql_injection, %{payload: found, severity: 5}}
    else
      {:sql_injection, nil}
    end
  end

  # Pattern 3: XSS Vulnerabilities
  defp scan_xss_vulnerabilities(target) do
    payload = "<script>alert('XSS')</script>"
    
    # Simulating a check on a search endpoint
    case HTTPoison.get("#{target}/search?q=#{URI.encode(payload)}") do
      {:ok, %HTTPoison.Response{body: body}} ->
        if String.contains?(body, payload) do
          Logger.warning("ðŸš¨ XSS VULNERABLE: #{target}")
          {:xss, %{severity: 3}}
        else
          {:xss, nil}
        end
      _ -> {:xss, nil}
    end
  end

  # Pattern 4: .git Exposure
  defp scan_git_exposure(target) do
    case HTTPoison.get("#{target}/.git/HEAD") do
      {:ok, %HTTPoison.Response{status_code: 200, body: body}} ->
        if String.contains?(body, "ref: refs/heads/") do
          Logger.warning("ðŸš¨ GIT REPO EXPOSED: #{target}")
          {:git_exposure, %{severity: 5}}
        else
          {:git_exposure, nil}
        end
      _ -> {:git_exposure, nil}
    end
  end

  # Pattern 5: API Keys in JS
  defp scan_api_keys(target) do
    # Fetch main page and look for patterns
    case HTTPoison.get(target) do
      {:ok, %HTTPoison.Response{body: body}} ->
        if String.match?(body, ~r/AIza[0-9A-Za-z-_]{35}/) do
          Logger.warning("ðŸš¨ GOOGLE API KEY EXPOSED: #{target}")
          {:api_key_exposure, %{type: "Google", severity: 4}}
        else
          {:api_key_exposure, nil}
        end
      _ -> {:api_key_exposure, nil}
    end
  end

  # Pattern 6: Weak Auth (Default Credentials)
  defp scan_weak_auth(target) do
    # Simulate login attempt
    creds = %{username: "admin", password: "password"}
    headers = [{"Content-Type", "application/json"}]
    
    case HTTPoison.post("#{target}/api/login", Jason.encode!(creds), headers) do
      {:ok, %HTTPoison.Response{status_code: 200}} ->
        Logger.warning("ðŸš¨ WEAK AUTH (Default Admin): #{target}")
        {:weak_auth, %{severity: 5}}
      _ -> {:weak_auth, nil}
    end
  end
end
